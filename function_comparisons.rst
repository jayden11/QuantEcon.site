.. _function_comparisons:

.. include:: org_banner.raw

========
CompEcon
========

.. .. contents:: :depth: 2

One of the main projects we have talked about undertaking is porting much of
the functionality from the CompEcon Matlab toolbox to Python and/or Julia.

The CompEcon source comes with a file named ``Contents.m`` that breaks
the functionality down into sections and then functions within each
section. We will replicate this formatting here. In each section we will
have a table that has 4 columns:

.. code::

    #. CompEcon function(ality)
    #. short description of usage
    #. where we can find it in the Python ecosystem, and
    #. where we can find it in the Julia ecosystem.

ROOTFINDING AND OPTIMIZATION
----------------------------

In this section assume we have run the code:

.. code:: python

    import scipy.optimize as opt

For notes on solving the complementarity see `this stack overflow
note <http://stackoverflow.com/questions/2171704/how-to-solve-an-lcp-linear-complementarity-problem-in-python>`__

+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| CompEcon |                                    Usage                                    |                                Python                                |                             Julia                             |
+==========+=============================================================================+======================================================================+===============================================================+
| BISECT   | Uses method of bisection to find roots for 1-D functions                    | ``opt.bisect``                                                       | ``QuantEcon.bisect``                                          |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| BROYDEN  | Computes root of function via Broyden's Inverse Method                      | ``opt.broyden1``, ``opt.broyden2``, ``opt.root([method='broyden*])`` | ``QuantEcon.brent`` (alternative to broyden)                  |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| BROYDENX | Computes root of function via Broyden's Method                              | See previous                                                         | ``QuantEcon.brent`` (alternative to broyden)                  |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| FIXPOINT | Computes fixpoint of function using function iteration                      | ``opt.fixed_point``                                                  | ``QuantEcon.compute_fixed_point``                             |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| GJACOBI  | Solves Ax=b using Jacobi iteration                                          | --                                                                   | ``IterativeSolvers.jacobi``                                   |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| GOLDEN   | Computes local maximum of univariate function on interval via Golden Search | ``opt.golden``                                                       | ``QuantEcon.golden_method``                                   |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| GOLDENX  | Computes local maximum of univariate function on interval via Golden Search | See Previous                                                         | ``QuantEcon.golden_method``                                   |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| GSEIDEL  | Solves Ax=b using Gauss-Seidel iteration                                    | --                                                                   | ``IterativeSolvers.gauss_seidel``                             |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| LCPBAARD | Uses block Baard method to solve linear complementarity problem             | --                                                                   | --                                                            |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| LCPLEMKE | Solves linear complementarity problem using Lemke's algorithm               | --                                                                   | --                                                            |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| LCPSOLVE | Solves linear complementarity problem using safeguarded Newton method       | --                                                                   | --                                                            |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| LEMKE    | Solves linear complementarity problems (LCPs).                              | --                                                                   | --                                                            |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| LPSOLVE  | Solves linear programming problems                                          | ``opt.linprog``                                                      | ``MathProgbase.linprog``                                      |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| MINMAX   | Minimax transformation for solving NCP as rootfinding problem               | --                                                                   | ``NLsolve.mcpsolve(f, xinit, lb, ub, reformulation=:minmax)`` |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| NCPJOSE  | Solves nonlinear complementarity problem using sequential LCP method        | --                                                                   | --                                                            |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| NCPSOLVE | Solves nonlinear complementarity problem                                    | ``dolo.numeric.optimize.ncpsolve``                                   | ``NLsolve.mcpsolve``                                          |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| NELDMEAD | Maximizes function via Nelder-Mead algorithm                                | ``opt.minimize([method='nelder-mead'])``                             | ``Optim.optimize(f, x0, NelderMead())``                       |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| NEWTON   | Computes root of function via Newton's Method with backstepping             | ``opt.newtwon``, ``dolo.numeric.optimize.ncpsolve``                  | ``NLsolve.nlsolve``                                           |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| OPTSTEP  | Solves a one dimensional optimal step length problem                        | --                                                                   | --                                                            |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| QNEWTON  | Solves unconstrained maximization problem using quasi-Newton                | ``opt.minimze([method="BFGS"])``                                     | ``NLopt.Opt(:LD_LBFGSS, ...)``                                |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+
| SMOOTH   | Reformulates an MCP as a semismooth function                                | ``dolo.numeric.optimize.smooth``                                     | ``NLsolve.mcpsolve(f, xinit, lb, ub, reformulation=:smooth)`` |
+----------+-----------------------------------------------------------------------------+----------------------------------------------------------------------+---------------------------------------------------------------+

Remarks: - For the sake of clarity, it may be interesting to rewrite in pure
python some of these functions that are currently calls to lower level
libraries. They can then be compiled using Numba. - An important thing to check
is what kind of jacobian these methods accept: dense, sparse, serial (special
case of sparse)

Quadrature
----------

All quadrature routines have been directly ported to python and live in
the ``quantecon.quad`` module.

The corresponding Julia versions are in QuantEcon.jl.

For this reason, neither Python nor Julia columns are found below.

+------------+--------------------------------------------------------------------------------+
| CompEcon   | Usage                                                                          |
+============+================================================================================+
| QNWBETA    | Computes quadrature nodes and weights for Beta(a,b) distribution               |
+------------+--------------------------------------------------------------------------------+
| QNWCHEB    | Computes multivariate Guass-Chebyshev quadrature nodes and weights             |
+------------+--------------------------------------------------------------------------------+
| QNWEQUI    | Generates equidistributed sequences                                            |
+------------+--------------------------------------------------------------------------------+
| QNWGAMMA   | Quadrature nodes and weights for Gamma(a) distribution                         |
+------------+--------------------------------------------------------------------------------+
| QNWLEGE    | Computes multivariate Guass-Legendre quadrature nodes and weights              |
+------------+--------------------------------------------------------------------------------+
| QNWLOGN    | Computes Gauss-Hermite nodes and weights multivariate lognormal distribution   |
+------------+--------------------------------------------------------------------------------+
| QNWNORM    | Computes nodes and weights for multivariate normal distribution                |
+------------+--------------------------------------------------------------------------------+
| QNWSIMP    | Computes multivariate Simpson quadrature nodes and weights                     |
+------------+--------------------------------------------------------------------------------+
| QNWTRAP    | Computes multivariate trapezoid rule quadrature nodes and weights              |
+------------+--------------------------------------------------------------------------------+
| QNWUNIF    | Computes nodes and weights for multivariate uniform distribution               |
+------------+--------------------------------------------------------------------------------+
| QUADRECT   | Integrates function on a rectangular region in R^n                             |
+------------+--------------------------------------------------------------------------------+

Function Approximation
----------------------

There are linear and cubic splines in ``dolo.numeric.interpolation``.

+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| CompEcon |                                 Usage                                 | Python |                                                  Julia                                                  |
+==========+=======================================================================+========+=========================================================================================================+
| CHEBBAS  | Computes basis matrices for Chebyshev polynomials                     | --     | ``BasisMatrices.evalbase(::ChebParams, ...)``                                                           |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| CHEBDEF  | Defines parameters for Chebyshev polynomial functions                 | --     | ``BasisMatrices.ChebParams(...)``                                                                       |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| CHEBDOP  | Creates differential operator matrices for Chebyshev polynomials.     | --     | ``BasisMatrices.derivative_op(::ChebParams, ...)``                                                      |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| CHEBNODE | Computes standard nodes for Chebyshev polynomials                     | --     | ``BasisMatrices.nodes(::ChebParams,...)`` or ``BasisMatrices.nodes(::Basis{1,Cheb})``                   |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FOURBAS  | Defines basis matrices for Fourier series                             | --     | --                                                                                                      |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FOURDEF  | Defines parameters for Fourier basis functions                        | --     | --                                                                                                      |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FOURDOP  | Computes differential operator for Fourier functions                  | --     | --                                                                                                      |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FOURNODE | Computes standard nodes for Fourier basis                             | --     | --                                                                                                      |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FUNBAS   | Computes a basis matrix                                               | --     | ``BasisMatrices.evalbase``                                                                              |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FUNBASX  | Creates basis structures for function evaluation                      | --     | ``BasisMatrices.evalbasex``                                                                             |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FUNBCONV | Converts among basis structure formats                                | --     | ``Base.convert(::Union{Type{Expanded},Type{Direct},Type{Tensor}}, ::BasisStructure, ...)``              |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FUNCONV  | Converts from one basis family to another                             | --     | ``Base.convert(::Union{Type{Expanded},Type{Direct},Type{Tensor}}, ::BasisStructure, ...)``              |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FUND     | Evaluates functions and first 2 derivatives                           | --     | not implemented, but can use ``BasisMatrices.funeval``                                                  |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FUNDEF   | Creates a fauction family definition structure and/or performs checks | --     | ``BasisMatrices.Basis(::BasisParams...)`` NOTE: much more flexible than just ``fundef`` and ``fundefn`` |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FUNDEFN  | Defines a function family structure                                   | --     | see above                                                                                               |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FUNDOP   | Computes derivative operators                                         | --     | ``BasisMatrices.derivative_op(::BasisParams)``                                                          |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FUNEVAL  | Evaluates multivariate functions with linear bases.                   | --     | ``BasisMatrices.funeval``                                                                               |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FUNFITF  | Computes interpolation coefficients for D-dim function.               | --     | ``BasisMatrices.funfitf``                                                                               |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FUNFITXY | Computes interpolation coefficients for d-dim function.               | --     | ``BasisMatrices.funfitxy``                                                                              |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FUNHESS  | Computes the Hessian for FUN functions                                | --     | not implemented, but can use ``BasisMatrices.funeval``                                                  |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FUNJAC   | Computes the Jacobian for FUN functions                               | --     | not implemented, but can use ``BasisMatrices.funeval``                                                  |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| FUNNODE  | Computes default nodes for a family of functions                      | --     | ``BasisMatrices.nodes(::Basis...)``                                                                     |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| LINBAS   | Piecewise linear basis functions                                      | --     | ``BasisMatrices.evalbase(::LinParams, ...)``                                                            |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| LINDEF   | Computes standard breakpoints for linear spline                       | --     | ``BasisMatrices.LinParams``                                                                             |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| LINDOP   | Differential operator for a piecewise linear function                 | --     | ``BasisMatrices.derivative_op(::LinParams,...)``                                                        |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| LINNODE  | Standard nodes for linear spline                                      | --     | ``BasisMatrices.nodes(::LinParams)``                                                                    |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| SPLIBAS  | Computes polynomial spline basis.                                     | --     | ``BasisMatrices.evalbase(::SplineParams, ...)``                                                         |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| SPLIDEF  | Defines default parameters for spline functions                       | --     | ``BasisMatrices.SplineParams``                                                                          |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| SPLIDOP  | Creates differential operator matrices for polynomial splines.        | --     | ``BasisMatrices.derivative_op(::SplineParams, ...)``                                                    |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+
| SPLINODE | Computes standard nodes for splines using knot averaging.             | --     | ``BasisMatrices.nodes(::SplineParams)``                                                                 |
+----------+-----------------------------------------------------------------------+--------+---------------------------------------------------------------------------------------------------------+

Discrete Time Dynamic Modeling
------------------------------

+-----------+----------------------------------------------------------------------------------------+------------------------------------------+-----------------------------------------------------------------+
|  CompEcon |                                         Usage                                          |                  Python                  |                              Julia                              |
+===========+========================================================================================+==========================================+=================================================================+
| DDPSIMUL  | Monte Carlo simulation of discrete-state/action controlled Markov process              | --                                       | ``QuantEcon.simulate(ddpr.mc)`` (where ``ddpr::DPSolveResult``) |
+-----------+----------------------------------------------------------------------------------------+------------------------------------------+-----------------------------------------------------------------+
| DDPSOLVE  | Solves discrete-state/action dynamic program                                           | ``DiscreteDP.solve``                     | ``solve(::DiscreteDP, ...)``                                    |
+-----------+----------------------------------------------------------------------------------------+------------------------------------------+-----------------------------------------------------------------+
| DPCHECK   | Checks derivatives for dp files                                                        | --                                       | --                                                              |
+-----------+----------------------------------------------------------------------------------------+------------------------------------------+-----------------------------------------------------------------+
| DISCRAND  | Discrete random variable simulator                                                     | ``DiscreteRV.draw()``                    | ``draw(::DiscreteRV)``                                          |
+-----------+----------------------------------------------------------------------------------------+------------------------------------------+-----------------------------------------------------------------+
| DPSIMUL   | Monte Carlo simulation of discrete time controlled Markov process                      | ``MarkovChain.simulate``                 | ``simulate(::MarkovChain)``                                     |
+-----------+----------------------------------------------------------------------------------------+------------------------------------------+-----------------------------------------------------------------+
| DPSOLVE   | Solves discrete time continuous-state/action dynamic program                           | ``dolo.time_iteration(NumericModel)``    | ``Dolo.time_iteration(m::NumericModel)``                        |
+-----------+----------------------------------------------------------------------------------------+------------------------------------------+-----------------------------------------------------------------+
| DPSTST    | Computes invariant distribution for continuous-state/action controlled dynamic program | --                                       | --                                                              |
+-----------+----------------------------------------------------------------------------------------+------------------------------------------+-----------------------------------------------------------------+
| GAMESOLVE | Solves discrete time continuous-state/action Bellman equations for dynamic games       | --                                       | --                                                              |
+-----------+----------------------------------------------------------------------------------------+------------------------------------------+-----------------------------------------------------------------+
| LQAPPROX  | Forms and solves linear-quadratic approximation of DP model                            | similar to ``quantecon.LQ(*args).solve`` | similar to ``solve(QuantEcon.LQ(*args))``                       |
+-----------+----------------------------------------------------------------------------------------+------------------------------------------+-----------------------------------------------------------------+
| MARKOV    | Analyzes Markov transition probability matrices                                        | ``quantecon.MarkovChain`` methods        | ``QuantEcon.MarkovChain`` methods                               |
+-----------+----------------------------------------------------------------------------------------+------------------------------------------+-----------------------------------------------------------------+
| REMSIMUL  | Simulates state paths in rational expectations models                                  | --                                       | --                                                              |
+-----------+----------------------------------------------------------------------------------------+------------------------------------------+-----------------------------------------------------------------+
| REMSOLVE  | Solves rational expectations models                                                    | ``dolo``                                 | --                                                              |
+-----------+----------------------------------------------------------------------------------------+------------------------------------------+-----------------------------------------------------------------+
| REMSTST   | Computes invariant distribution for rational expectations models                       | --                                       | --                                                              |
+-----------+----------------------------------------------------------------------------------------+------------------------------------------+-----------------------------------------------------------------+

Remark: the compecon toolbox defines models as a Matlab file, with a
switch variable to choose between equations. ``dolo`` defines model as
YAML files instead and generates the functions on the fly. The spirit is
very close though.

Possibly relevant too, by Pierre Haessig:
`stodynprog <https://github.com/pierre-haessig/stodynprog>`__

ODE Solvers and Continuous time Dynamic Modeling
------------------------------------------------

+-----------------+------------------------------------------------------------------+----------+---------+
| CompEcon        | Usage                                                            | Python   | Julia   |
+=================+==================================================================+==========+=========+
| AFFASSET        | Solves affine asset pricing models                               | --       | --      |
+-----------------+------------------------------------------------------------------+----------+---------+
| BVPSOLVE        | Solves general first order boundary value problems               | --       | --      |
+-----------------+------------------------------------------------------------------+----------+---------+
| CTBASEMAKE      | Basis matrices for continuous time collocation                   | --       | --      |
+-----------------+------------------------------------------------------------------+----------+---------+
| CTSTEADYSTATE   | Finds deterministic steady state for continuous time models      | --       | --      |
+-----------------+------------------------------------------------------------------+----------+---------+
| FINDSTATE       | Calibrates an asset pricing model to data                        | --       | --      |
+-----------------+------------------------------------------------------------------+----------+---------+
| FINSOLVE        | Solves continuous time asset pricing problems                    | --       | --      |
+-----------------+------------------------------------------------------------------+----------+---------+
| ICSOLVE         | Solves continuous time impulse control models                    | --       | --      |
+-----------------+------------------------------------------------------------------+----------+---------+
| ITODENSITY      | Long-run densities for 1-D Ito processes                         | --       | --      |
+-----------------+------------------------------------------------------------------+----------+---------+
| ITOSIMUL        | Monte Carlo simulation of a (possibly) controlled Ito process    | --       | --      |
+-----------------+------------------------------------------------------------------+----------+---------+
| RK              | 4 Solves initial value problems using fourth-order Runge-Kutta   | --       | --      |
+-----------------+------------------------------------------------------------------+----------+---------+
| RSSOLVE         | Solves continuous time regime switching models                   | --       | --      |
+-----------------+------------------------------------------------------------------+----------+---------+
| SCSOLVE         | Solves stochastic control problems                               | --       | --      |
+-----------------+------------------------------------------------------------------+----------+---------+

Utilities
---------

+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
|  CompEcon |                              Usage                              |                     Python                    |                                                    Julia                                                     |
+===========+=================================================================+===============================================+==============================================================================================================+
| CHECKJAC  | Compares analytic and finite difference derivative              | --                                            | ``check_gradient``, ``check_derivative``, ``check_second_derivative`` and ``check_hessian`` from Calculus.jl |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| CHKFIELDS | Checks if a variable S is a valid structure with fields F       | NA                                            | NA                                                                                                           |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| CKRON     | Repeated Kronecker products on a cell array of matrices         | ``quantecon.ckron``                           | ``QuantEcon.ckron``                                                                                          |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| CKRONX    | The product of repeated Kronecker products and a matrix         | --                                            | ``BasisMatrices.ckronx``                                                                                     |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| CKRONXI   | The product of repeated inverse Kronecker products and a matrix | --                                            | ``BasisMatrices.ckronxi``                                                                                    |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| CSIZE     | Returns dimension information for cell arrays                   | ``[x.shape for x in arrays]``                 | ``map(size, x::Vector{<:AbstractArray})``                                                                    |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| GETINDEX  | Finds the index value of a point                                | ``np.where``                                  | ``find`` or ``findfirst``                                                                                    |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| GRIDMAKE  | Forms grid points                                               | ``quantecon.cartesian``                       | ``QuantEcon.gridmake``                                                                                       |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| INDEX     | Converts between single and multiple indices                    | --                                            | ``sub2ind`` and ``ind2sub``                                                                                  |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| KERNEL    | Computes a kernel estimate of a PDF                             | ``scipy.stats.gaussian_kde``                  | ``KernelDensity.kde(data, ::Distribution)``                                                                  |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| LOOKUP    | Performs a table lookup                                         | ``np.searchsorted`` with boundary adjustments | ``BasisMatrices.lookup``                                                                                     |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| MEXALL    | Creates MEX files for CompEcon toolbox                          | NA                                            | NA                                                                                                           |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| MINTERP   | Multidimensional interpoation                                   | ``scipy.interpolate.LinearNDInterpolator``    | use ``BasisMatrices.LinParams`` and evaluation methods (new API coming soon)                                 |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| NODEUNIF  | Computes uniform nodes for intervals R^n                        | --                                            | ``map(linspace, [a1, a2, ...], [b1, b2, ...], [n1, n2, ...])``                                               |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| OPTGET    | Utility to get previously set function default values           | NA                                            | NA                                                                                                           |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+
| OPTSET    | Utility to set function options                                 | NA                                            | NA                                                                                                           |
+-----------+-----------------------------------------------------------------+-----------------------------------------------+--------------------------------------------------------------------------------------------------------------+

Special Functions and Misc
--------------------------

+------------+--------------------------------------------------------------+--------------------------------------------------------+----------------------------------------------+
| CompEcon   | Usage                                                        | Python                                                 | Julia                                        |
+============+==============================================================+========================================================+==============================================+
| BAW        | Barone-Adesi/Whaley American option pricing model            | --                                                     | --                                           |
+------------+--------------------------------------------------------------+--------------------------------------------------------+----------------------------------------------+
| BS         | Black-Scholes option pricing model                           | --                                                     | --                                           |
+------------+--------------------------------------------------------------+--------------------------------------------------------+----------------------------------------------+
| CDFN       | Computes the CDF of the standard normal distribution         | ``scipy.stats.norm.cdf(x, 0, 1)``                      | ``cdf(Distributions.Normal(...), ...)``      |
+------------+--------------------------------------------------------------+--------------------------------------------------------+----------------------------------------------+
| CONFHYP    | Computes the confluent hypergeometric function               | ``scipy.special.hyp1f1`` or ``scipy.special.hyp1f2``   | --                                           |
+------------+--------------------------------------------------------------+--------------------------------------------------------+----------------------------------------------+
| DIGAMMA    | Computes the digamma (psi) function for positive arguments   | ``scipy.special.digamma``                              | ``Base.digamma``                             |
+------------+--------------------------------------------------------------+--------------------------------------------------------+----------------------------------------------+
| FDHESS     | Computes finite difference Hessian                           | ``numdifftools.Hessian(f)(x)``                         | ``Calculus.hessian``                         |
+------------+--------------------------------------------------------------+--------------------------------------------------------+----------------------------------------------+
| FDJAC      | Computes two-sided finite difference Jacobian                | ``numdifftools.Hessian(f)(x)``                         | ``Calculus.gradient``                        |
+------------+--------------------------------------------------------------+--------------------------------------------------------+----------------------------------------------+
| FHESS      | Alternative finite difference Hessian procedure              | NA                                                     | NA                                           |
+------------+--------------------------------------------------------------+--------------------------------------------------------+----------------------------------------------+
| FJAC       | Alternative finite difference Jacobian procedure             | NA                                                     | NA                                           |
+------------+--------------------------------------------------------------+--------------------------------------------------------+----------------------------------------------+
| IMPVOL     | Computes option implied volatilities                         | --                                                     | --                                           |
+------------+--------------------------------------------------------------+--------------------------------------------------------+----------------------------------------------+
| MONTNORM   | Computes pseudo-random multivariate normal variates          | ``st.multivariate_normal.rvs(mu, sig, size=(...))``    | ``rand(Distributions.MvNormal(...), ...)``   |
+------------+--------------------------------------------------------------+--------------------------------------------------------+----------------------------------------------+
| PSI        | Calculates the value of the psi (digamma) function           | ``scipy.special.digamma``                              | ``Base.digamma``                             |
+------------+--------------------------------------------------------------+--------------------------------------------------------+----------------------------------------------+
| TRIGAMMA   | Calculates the value of the trigamma function                | ``special.polygamma(1, x)``                            | ``Base.trigamma``                            |
+------------+--------------------------------------------------------------+--------------------------------------------------------+----------------------------------------------+

